from __future__ import print_function
from numpy import zeros,exp,cumsum,round
from numpy.random import normal,laplace
from numpy.lib.scimath import log,sqrt
from scipy import stats

class Simulation:
    def __init__(self):
        '''
        __init__() -> class constructor.

        Returns
        -------
        None.
        '''
        self.__distribution__="normal"
        self.__minprice__=0.0
        self.__nperiods__=self.__max_missed__=120
        self.__npaths__=1000
        self.__volatility__=0.2
        self.__n__=100
        self.__inibalance__=100000.0
        self.__s0__=100.0
        self.__r__=0.01
        self.__call_otm_level__=self.__put_otm_level__=0.05
        self.__balance__=self.__stock__=None
        self.__s__=None
        self.__missed__=None
        self.__nopencalls__=self.__nopenputs__=None
        self.__nexercisedcalls__=self.__nexercisedputs__=None
        self.__toggle__=True
        self.__savelog__=False
        
    def run(self):
        '''
        run() -> runs a Monte Carlo simulation.

        Returns
        -------
        None.
        '''
        self.__balance__=zeros((self.__npaths__,self.__nperiods__))
        self.__balance__[:,0]=self.__inibalance__
        self.__stock__=zeros((self.__npaths__,self.__nperiods__),int)
        self.__missed__=zeros(self.__npaths__,int)
        self.__nopencalls__=zeros(self.__npaths__,int)
        self.__nopenputs__=zeros(self.__npaths__,int)
        self.__nexercisedcalls__=zeros(self.__npaths__,int)
        self.__nexercisedputs__=zeros(self.__npaths__,int)
        t=1.0/252.0
        sigma=self.__volatility__*sqrt(t)
        days_per_period=21
        minprice=self.__s0__*self.__minprice__
        
        if self.__distribution__=="normal":
            self.__s__=sigma*normal(0,1,(self.__npaths__,
                                         self.__nperiods__*days_per_period))
        elif self.__distribution__=="normal-risk-neutral":
            self.__s__=(self.__r__-0.5*self.__volatility__**2.0)*t+\
                sigma*normal(0,1,(self.__npaths__,
                                  self.__nperiods__*days_per_period))
        elif self.__distribution__=="laplace":
            self.__s__=sigma/sqrt(2.0)*\
                laplace(0,1,(self.__npaths__,
                             self.__nperiods__*days_per_period))

        self.__s__[:,0]=log(self.__s0__)
        self.__s__=round(exp(cumsum(self.__s__,axis=1)),2)
        
        if self.__savelog__:
            with open("log.dat","w") as f:
                f.write("-------- LOG --------\n\n")
        
        for i in range(self.__npaths__):
            writtencall=writtenput=False
            xc=xp=None
            purchaseprice=[]
            nconsecmissed=0
            
            if self.__savelog__:
                strlog="TRADING PATH #%d\n" % i
                
            for j in range(self.__nperiods__):
                missed=True
                m=(j+1)*days_per_period-1
                day_1=m-days_per_period+1
                
                if self.__savelog__:
                    strlog+="   PERIOD #%d\n" % j
                    strlog+="      Spot price at day 1: %.2f\n" \
                        % self.__s__[i,day_1]
                
                if j>0:
                    self.__balance__[i,j]=self.__balance__[i,j-1]
                    self.__stock__[i,j]=self.__stock__[i,j-1]
                
                # Open new put and/or call positions
                if len(purchaseprice)==0 or nconsecmissed>=self.__max_missed__:
                    xp=round((self.__s__[i,day_1]-self.__s__[i,day_1]*
                              self.__put_otm_level__),2)
                    newbalance=self.__balance__[i,j]-xp*self.__n__
                
                    if xp>=minprice and newbalance>=0.0:
                        p=self.__getoptionprice__("put",
                                                  self.__s__[i,day_1],
                                                  xp,(days_per_period-1)/252.0)
                        self.__balance__[i,j]+=p*self.__n__
                        self.__nopenputs__[i]+=1
                        nconsecmissed=0
                        writtenput=True
                        
                        if missed:
                            missed=False
                            
                        if self.__savelog__:
                            strlog+="      ------\n"
                            strlog+="      Cash-secured put is written!\n"
                            strlog+="         Days to maturity: %d\n" \
                                % (days_per_period-1)
                            strlog+="         Put strike: %.2f\n" % xp
                            strlog+="         Put premium: %.2f\n" % p                
                
                if len(purchaseprice)>0:
                    xc=[0.0 for x in purchaseprice]
                    
                    for l in range(day_1,m):   
                        if 0.0 not in xc:
                            break
                        
                        for k in range(len(purchaseprice)):
                            if xc[k]>0.0:
                                continue

                            if purchaseprice[k]<=self.__s__[i,l]:
                                xc[k]=round((self.__s__[i,l]+self.__s__[i,l]*
                                             self.__call_otm_level__),2)
                                t2maturity=((m-l)/252.0)
                                c=self.__getoptionprice__("call",
                                                          self.__s__[i,l],
                                                          xc[k],t2maturity)
                        
                                self.__balance__[i,j]+=c*self.__n__
                                self.__nopencalls__[i]+=1
                                nconsecmissed=0
                                        
                                if missed:
                                    missed=False
                                    
                                if not writtencall:
                                    writtencall=True
                    
                                if self.__savelog__:
                                    strlog+="      ------\n"
                                    strlog+="      Covered call is written!\n"
                                    strlog+="         Spot price: %.2f\n" % \
                                        self.__s__[i,l]
                                    strlog+="         Days to maturity: %d\n" % \
                                        (m-l)
                                    strlog+="         Call strike: %.2f\n" % \
                                        xc[k]
                                    strlog+="         Call premium: %.2f\n" % \
                                        c
                                    strlog+="         Stock purchase price: %.2f\n" \
                                        % purchaseprice[k]
                    else:
                        if not writtencall:
                            nconsecmissed+=1
                    
                # Check if open call and/or puts are exercised
                if self.__savelog__:
                    strlog+="      ------\n"
                    strlog+="      Spot price at maturity: %.2f\n" \
                            %self.__s__[i,m]
                                    
                if writtencall:
                    for k in range(len(purchaseprice)):                    
                        if xc[k]>0.0 and xc[k]<=self.__s__[i,m]:
                            self.__balance__[i,j]+=xc[k]*self.__n__
                            self.__stock__[i,j]-=self.__n__
                            self.__nexercisedcalls__[i]+=1
                                    
                            if self.__savelog__:
                                strlog+="      ------\n"
                                strlog+="      Call was exercised!\n"
                                strlog+="         Stock sale price: %.2f\n" \
                                    % xc[k]
                                strlog+="         Stock purchase price: %.2f\n" \
                                    % purchaseprice[k]
                                strlog+="         Profit: %.2f\n" % \
                                    (xc[k]-purchaseprice[k])
                                    
                            purchaseprice[k]=0.0
                                        
                    purchaseprice=[x for x in purchaseprice if x>0.0]
                    
                    writtencall=False
                    
                if writtenput: 
                    if xp>=self.__s__[i,m]:
                        self.__balance__[i,j]-=xp*self.__n__
                        self.__stock__[i,j]+=self.__n__
                        self.__nexercisedputs__[i]+=1
                        
                        purchaseprice.append(xp)
                           
                        if self.__savelog__:
                            strlog+="      ------\n"
                            strlog+="      Put was exercised!\n"
                            strlog+="         Stock purchase price: %.2f\n" % xp
                    
                    writtenput=False
                        
                if missed:
                    self.__missed__[i]+=1
                    
                    if self.__savelog__:
                        strlog+="      ------\n"
                        strlog+="      No trade was open!\n"
                        
                if self.__savelog__:
                    strlog+="      ------\n"
                    strlog+="      Balance: %.2f\n" % self.__balance__[i,j]
                    strlog+="      Number of shares: %d\n" % \
                        self.__stock__[i,j]
                        
                    if len(purchaseprice)>0:
                        strlog+="      Purchase prices: %s\n" % purchaseprice
                        strlog+="      Stock price: %.2f\n" % self.__s__[i,m]
                        strlog+="      Total stock position: %.2f\n" %\
                            (self.__s__[i,m]*self.__stock__[i,j])
                        
                    strlog+="      Total position: %.2f\n" % \
                        (self.__balance__[i,j]+self.__stock__[i,j]*
                         self.__s__[i,m])
                
            if self.__savelog__:
                with open("log.dat","a") as f:
                    f.write(strlog)

    def __getoptionprice__(self,optype,s,x,time2maturity):
        '''
        __getoptionprice__(optype,s,x) -> returns the premium of an option.

        Parameters
        ----------
        optype : string
            Option type (either 'call' or 'put').
        s : float
            Stock price.
        x : float
            Strike.
        time2maturity : float
            Time left to maturity.

        Returns
        -------
        premium : float
            Option premium.
        '''
        d1=(log(s/x)+(self.__r__+self.__volatility__*self.__volatility__/2.0)*
            time2maturity)/(self.__volatility__*sqrt(time2maturity))
        d2=d1-self.__volatility__*sqrt(time2maturity)        
        
        if optype=="call":		
            premium=round((s*stats.norm.cdf(d1)-
                           x*exp(-self.__r__*time2maturity)*
                           stats.norm.cdf(d2)),2)
        elif optype=="put":
            premium=round((x*exp(-self.__r__*time2maturity)*
                           stats.norm.cdf(-d2)-s*stats.norm.cdf(-d1)),2)
                
        return premium
    
    '''
    Class attributes
    ----------------
    distribution : string, optional
        Statistical distribution used in stock price calculations (it can be  
        'normal', 'normal-risk-neutral' or 'laplace'). Default is 'normal'.
    number_of_options : integer, optional
        Number of options contracts (and, consequently, of shares, when 
        exercised). Default is 100.
    number_of_trading_paths : integer, optional
        Number of independent trading paths generated by Monte Carlo. Default 
        is 1,000.
    number_of_periods : integer, optional
        Number of trading periods per trading path. Default is 120 (it 
        corresponds to 10 years, each period corresponding to one month).
    initial_balance : float, optional
        Initial capital available for trading. Default is US$ 100,000.
    initial_stock_price : float, optional
        Initial price per share of the underlying asset. Default is US$ 100.
    minimum_price : float, optional
        Minimum price, as a fraction of the initial stock price, below which 
        no puts are written. Default is 0.80 (80% of the initial stock price).
    volatility : float, optional
        Volatility of the underlying asset. Default is 0.25 (25%).
    risk_free_rate : float, optional
        Risk-free interest rate of the economy. Default is 0.01 (1%).
    call_otm_level : float, optional
        Call option strike position above the spot price in a given period. 
        Default is 0.05 (strike is 5% higher than the spot price).
    put_otm_level : float, optional
        Put option strike position below the spot price in a given period. 
        Default is 0.05 (strike is 5% lower than the spot price).
    maximum_missed_calls : integer, optional
        Maximum number of periods in which calls are not written after which 
        puts will be written even if the number of stocks owned is greater than 
        zero. Default is 120.
    save_log : boolean, optional
        Whether or not to save a log. Default is False.
    '''       
    @property
    def distribution(self):
        return self.__distribution__
    
    @distribution.setter
    def distribution(self,x):
        if x=="normal" or x=="normal-risk-neutral" or x=="laplace":
            self.__distribution__=x
        else:
            raise ValueError("It must be either 'normal' or 'normal-risk-neutral' or 'laplace'!")
            
    @property
    def number_of_options(self):
        return self.__n__
    
    @number_of_options.setter
    def number_of_options(self,x):
        if isinstance(x,int) and x>0:
            self.__n__=x
        else:
            raise ValueError("An integer greater than zero is expected!")

    @property
    def number_of_trading_paths(self):
        return self.__npaths__
    
    @number_of_trading_paths.setter
    def number_of_trading_paths(self,x):
        if isinstance(x,int) and x>0:
            self.__npaths__=x
        else:
            raise ValueError("An integer greater than zero is expected!")
 
    @property
    def number_of_periods(self):
        return self.__nperiods__
    
    @number_of_periods.setter
    def number_of_periods(self,x):
        if isinstance(x,int) and x>0:
            self.__nperiods__=x
        else:
            raise ValueError("An integer greater than zero is expected!")
        
    @property
    def initial_balance(self):
        return self.__inibalance__
    
    @initial_balance.setter
    def initial_balance(self,x):
        if isinstance(x,(int,float)) and x>=0.0:
            self.__inibalance__=x
        else:
            raise ValueError("A number greater than or equal to zero is expected!")
    
    @property
    def initial_stock_price(self):
        return self.__s0__
    
    @initial_stock_price.setter
    def initial_stock_price(self,x):
        if isinstance(x,(int,float)) and x>0.0:
            self.__s0__=x
        else:
            raise ValueError("A number greater than zero is expected!")
            
    @property
    def minimum_price(self):
        return self.__minprice__
    
    @minimum_price.setter
    def minimum_price(self,x):
        if isinstance(x,float) and x>=0.0 and x<1.0:
            self.__minprice__=x
        else:
            raise ValueError("A number in the [0,1[ interval is expected!")

    @property
    def volatility(self):
        return self.__volatility__
    
    @volatility.setter
    def volatility(self,x):
        if isinstance(x,float) and x>0.0:
            self.__volatility__=x
        else:
            raise ValueError("A number greater than zero is expected!")

    @property
    def risk_free_rate(self):
        return self.__r__
    
    @risk_free_rate.setter
    def risk_free_rate(self,x):
        if isinstance(x,float) and x>=0.0:
            self.__r__=x
        else:
            raise ValueError("A number greater than or equal to zero is expected!")
            
    @property
    def call_otm_level(self):
        return self.__call_otm_level__

    @call_otm_level.setter
    def call_otm_level(self,x):
        if isinstance(x,float) and x>=0.0:
            self.__call_otm_level__=x
        else:
            raise ValueError("A number greater than or equal to zero is expected!")
            
    @property
    def put_otm_level(self):
        return self.__put_otm_level__

    @put_otm_level.setter
    def put_otm_level(self,x):
        if isinstance(x,float) and x>=0.0:
            self.__put_otm_level__=x
        else:
            raise ValueError("A number greater than or equal to zero is expected!")

    @property
    def maximum_missed_calls(self):
        return self.__max_missed__
    
    @maximum_missed_calls.setter
    def maximum_missed_calls(self,x):
        if isinstance(x,int) and x>=0:
            self.__max_missed__=x
        else:
            raise ValueError("An integer greater than or equal to zero is expected!")

    @property
    def save_log(self):
        return self.__savelog__
    
    @save_log.setter
    def save_log(self,x):
        if isinstance(x,bool):
            self.__savelog__=x
        else:
            raise ValueError("A boolean value is expected!")

    '''
    Reand-only class properties
    ---------------------------
    stock_prices : array
        2D Numpy array containing the stock prices generated by Monte Carlo.
    balance : array
        2D Numpy array containing the evolution of the balance along the 
        simulated trading paths.
    stock : array
        2D Numpy array containing the evolution of the stock position along the 
        simulated trading paths.
    missed_trades : array
        Numpy array containing the number of missed trades for each trading 
        path.
    exercised_calls : array
        Numpy array containing the number of exercised call positions for each 
        trading path.
    exercised_puts : array
        Numpy array containing the number of exercised put positions for each 
        trading path.
    '''
    @property
    def stock_prices(self):
        return self.__s__
    
    @property
    def balance(self):
        return self.__balance__
    
    @property
    def stock(self):
        return self.__stock__
            
    @property
    def missed_trades(self):
        return self.__missed__
    
    @property
    def open_calls(self):
        return self.__nopencalls__
    
    @property
    def open_puts(self):
        return self.__nopenputs__
    
    @property
    def exercised_calls(self):
        return self.__nexercisedcalls__
    
    @property
    def exercised_puts(self):
        return self.__nexercisedputs__
    
