from numpy import full, zeros, exp, cumsum, round, ndarray
from numpy.random import normal
from numpy.lib.scimath import log, sqrt
from scipy import stats
from .models import InputData, SimulationData, _DAYS_PER_PERIOD


def run_simulation(inputs: InputData | dict) -> SimulationData:
    """
    Simulates the Wheel strategy for a number of price paths of the underlying asset
    assuming a Black-Scholes world.

    Parameters
    ----------
    inputs : InputData | dict
        Inputs used in the simulation, as follows:
            number_of_options : integer, optional
                Number of options in a contract. Default is 100.
            number_of_trading_paths : integer, optional
                Number of independent trading paths generated by Monte Carlo. Default
                is 100,000.
            number_of_periods : integer, optional
                Number of trading periods per trading path. Default is 120 (it
                corresponds to 10 years, each period corresponding to one month).
            initial_stock_price : float, optional
                Initial price per share of the underlying asset. Default is US$ 100.
            initial_money : float, optional
                Initial capital available in the trading account before any transaction.
                Default is zero.
            minimum_price_factor : float, optional
                Fraction of the initial stock price below which no puts are written.
                Default is zero, which means US$ 0.01.
            volatility : float, optional
                Annualized volatility of the underlying asset. Default is 0.2.
            risk_free_rate : float, optional
                Annualized risk-free interest rate of the economy. Default is 0.01.
            call_strike_factor : float, optional
                Call option strike position above (if positive, OTM) or below (if
                negative, ITM) the spot price in a given period. Default is 0.05
                (strike is 5% OTM).
            put_strike_factor : float, optional
                Put option strike position below (if positive, OTM) or above (if
                negative, ITM) the spot price in a given period. Default is 0.05
                (strike is 5% OTM).
            covered_calls_deadline : integer, optional
                Maximum number of days in a trading month after which calls are not
                more written. Default is the number of days in a trading period.
            write_puts_if_no_calls : boolean, optional
                Puts are sold in a period where calls are supposed to be the active
                transaction but the condition for selling calls was not fulfilled
                until the dealine. Default is False.
            save_log : boolean, optional
                Whether or not to save a log. Default is False.

    Returns
    -------
    SimulationData
        Output data generated by the simulation, as follows:
            stock_prices : array
                2D Numpy array containing the stock prices generated by Monte Carlo.
            money : array
                2D Numpy array containing the money in the trading account.
            stock : array
                2D Numpy array containing the number of shares owned by the trader.
            money_spent : array
                Numpy array containing the money spent by the trader to cover the
                assigned puts at the end of trading paths.
            missed_trades : array
                Numpy array containing the total number of missed trades at the end of
                trading paths.
            open_calls : array
                Numpy array containing the total number of open calls.
            open_puts : array
                Numpy array containing the total number of open puts.
            exercised_calls : array
                Numpy array containing the total number of exercised calls.
            exercised_puts : array
                Numpy array containing the total number of exercised puts.
    """
    inputs = (
        inputs if isinstance(inputs, InputData) else InputData.model_validate(inputs)
    )

    money = zeros((inputs.number_of_trading_paths, inputs.number_of_periods))
    money[:, 0] = inputs.initial_money
    stock = zeros((inputs.number_of_trading_paths, inputs.number_of_periods), int)
    missed_trades = zeros(inputs.number_of_trading_paths, int)
    open_calls = zeros(inputs.number_of_trading_paths, int)
    open_puts = zeros(inputs.number_of_trading_paths, int)
    exercised_calls = zeros(inputs.number_of_trading_paths, int)
    exercised_puts = zeros(inputs.number_of_trading_paths, int)
    money_spent = full(inputs.number_of_trading_paths, inputs.initial_money)
    minimum_price = (
        inputs.initial_stock_price * inputs.minimum_price_factor
        if inputs.initial_stock_price * inputs.minimum_price_factor > 0.01
        else 0.01
    )

    stock_prices = _gen_price_paths(
        inputs.initial_stock_price,
        inputs.risk_free_rate,
        inputs.volatility,
        inputs.number_of_periods,
        inputs.number_of_trading_paths,
    )

    if inputs.save_log:
        with open("log.dat", "w") as f:
            f.write("-------- LOG --------\n\n")

    for i in range(inputs.number_of_trading_paths):
        written_call = written_put = False
        purchase_price = []

        if inputs.save_log:
            strlog = "TRADING PATH #%d\n" % i

        for j in range(inputs.number_of_periods):
            missed = True
            write_put = False
            m = (j + 1) * _DAYS_PER_PERIOD - 1
            day_1 = m - _DAYS_PER_PERIOD + 1

            if inputs.save_log:
                strlog += "   PERIOD #%d\n" % j
                strlog += "      Spot price at day 1: %.2f\n" % stock_prices[i, day_1]

            if j > 0:
                money[i, j] = money[i, j - 1]
                stock[i, j] = stock[i, j - 1]

            # Open new call or put position
            if len(purchase_price) > 0:
                xc = [0.0 for x in purchase_price]
                write_put = False

                for l in range(day_1, m):
                    if 0.0 not in xc:
                        break
                    elif (l - day_1) == inputs.covered_calls_deadline:
                        if inputs.write_puts_if_no_calls and not written_call:
                            write_put = True

                        break
                    else:
                        xctmp = round(
                            (
                                stock_prices[i, l]
                                + stock_prices[i, l] * inputs.call_strike_factor
                            ),
                            2,
                        )
                        t2m = (m - l) / 252.0
                        c = _get_option_price(
                            "call",
                            stock_prices[i, l],
                            xctmp,
                            inputs.risk_free_rate,
                            inputs.volatility,
                            t2m,
                        )

                        if c < 0.01:
                            c = 0.01

                    for k in range(len(purchase_price)):
                        if xc[k] > 0.0:
                            continue

                        if (xctmp + c) > purchase_price[k]:
                            xc[k] = xctmp
                            money[i, j] += c * inputs.number_of_options
                            open_calls[i] += 1

                            if missed:
                                missed = False

                            if not written_call:
                                written_call = True

                            if inputs.save_log:
                                strlog += "      ------\n"
                                strlog += "      Covered call is written!\n"
                                strlog += (
                                    "         Spot price: %.2f\n" % stock_prices[i, l]
                                )
                                strlog += "         Days to maturity: %d\n" % (m - l)
                                strlog += "         Call strike: %.2f\n" % xc[k]
                                strlog += "         Call premium: %.2f\n" % c
                                strlog += (
                                    "         Stock purchase price: %.2f\n"
                                    % purchase_price[k]
                                )

            if len(purchase_price) == 0 or write_put:
                if write_put:
                    day_open_put = day_1 + inputs.covered_calls_deadline - 1
                    write_put = False
                else:
                    day_open_put = day_1

                t2m = (m - day_open_put) / 252.0
                xp = round(
                    (
                        stock_prices[i, day_open_put]
                        - stock_prices[i, day_open_put] * inputs.put_strike_factor
                    ),
                    2,
                )

                if xp >= minimum_price:
                    p = _get_option_price(
                        "put",
                        stock_prices[i, day_open_put],
                        xp,
                        inputs.risk_free_rate,
                        inputs.volatility,
                        t2m,
                    )

                    if p < 0.01:
                        p = 0.01

                    money[i, j] += p * inputs.number_of_options
                    open_puts[i] += 1
                    written_put = True

                    if missed:
                        missed = False

                    if inputs.save_log:
                        strlog += "      ------\n"
                        strlog += "      Cash-secured put is written!\n"
                        strlog += "         Days to maturity: %d\n" % (m - day_open_put)
                        strlog += "         Put strike: %.2f\n" % xp
                        strlog += "         Put premium: %.2f\n" % p
            # ---

            # Check if an open call or put is exercised
            if inputs.save_log:
                strlog += "      ------\n"
                strlog += "      Spot price at maturity: %.2f\n" % stock_prices[i, m]

            if written_call:
                for k in range(len(purchase_price)):
                    if xc[k] > 0.0 and xc[k] <= stock_prices[i, m]:
                        money[i, j] += xc[k] * inputs.number_of_options
                        stock[i, j] -= inputs.number_of_options
                        exercised_calls[i] += 1

                        if inputs.save_log:
                            strlog += "      ------\n"
                            strlog += "      Call was exercised!\n"
                            strlog += "         Stock sale price: %.2f\n" % xc[k]
                            strlog += (
                                "         Stock purchase price: %.2f\n"
                                % purchase_price[k]
                            )

                        purchase_price[k] = 0.0

                purchase_price = [x for x in purchase_price if x > 0.0]
                written_call = False

            if written_put:
                if xp >= stock_prices[i, m]:
                    money[i, j] -= xp * inputs.number_of_options
                    stock[i, j] += inputs.number_of_options
                    exercised_puts[i] += 1

                    purchase_price.append(xp)

                    if inputs.save_log:
                        strlog += "      ------\n"
                        strlog += "      Put was exercised!\n"
                        strlog += "         Stock purchase price: %.2f\n" % xp

                    if money[i, j] < 0.0:
                        money_spent[i] -= money[i, j]

                        if inputs.save_log:
                            strlog += "         Money from pocket: %.2f\n" % (
                                -money[i, j]
                            )

                        money[i, j] = 0.0

                written_put = False
            # ---

            if missed:
                missed_trades[i] += 1

                if inputs.save_log:
                    strlog += "      ------\n"
                    strlog += "      No trade was open!\n"

            if inputs.save_log:
                strlog += "      ------\n"
                strlog += "      Invested money: %.2f\n" % money_spent[i]
                strlog += "      Money in account: %.2f\n" % money[i, j]
                strlog += "      Number of shares: %d\n" % stock[i, j]

                if len(purchase_price) > 0:
                    strlog += "      Purchase prices: %s\n" % purchase_price
                    strlog += "      Stock price: %.2f\n" % stock_prices[i, m]
                    strlog += "      Total stock position: %.2f\n" % (
                        stock_prices[i, m] * stock[i, j]
                    )

                strlog += "      Total position (money+stock): %.2f\n" % (
                    money[i, j] + stock[i, j] * stock_prices[i, m]
                )

        if inputs.save_log:
            with open("log.dat", "a") as f:
                f.write(strlog)

        return SimulationData(
            stock_prices=stock_prices,
            money=money,
            stock=stock,
            money_spent=money,
            missed_trades=missed_trades,
            open_calls=open_calls,
            open_puts=open_puts,
            exercised_calls=exercised_calls,
            exercised_puts=exercised_puts,
        )


def _gen_price_paths(
    s0: float, r: float, vol: float, nperiods: int, npaths: int
) -> ndarray:
    """
    Generates price paths.

    Parameters
    ----------
    s0 : float
        Initial stock price.
    r : float
        Annualized risk free interest rate.
    vol : float
        Annualized volatility.
    nperiods : int
        Number of trading periods.
    npaths : int
        Number of price paths.

    Returns
    -------
    ndarray
        Simulated price paths.

    """
    T = nperiods * _DAYS_PER_PERIOD  # Total simulated time, in days.
    t = 1.0 / T  # Fraction of T corresponding to one trading day
    r = r / 12 * nperiods  # Risk-free interest rate for T
    vol = vol * sqrt(T / 252)  # Volatility for T
    s = (r - 0.5 * vol**2.0) * t + vol * sqrt(t) * normal(0, 1, (npaths, T))
    s[:, 0] = log(s0)
    s = round(exp(cumsum(s, axis=1)), 2)

    return s


def _get_option_price(
    optype: str, s: float, x: float, r: float, vol: float, time_to_maturity: float
) -> float:
    """
    Returns the premium of an option calculated using the Black-Scholes model.

    Parameters
    ----------
    optype : string
        Option type (either 'call' or 'put').
    s : float
        Stock price.
    x : float
        Strike.
    time_to_maturity : float
        Time left to maturity, in years.

    Returns
    -------
    float
        Option premium.
    """
    d1 = (log(s / x) + (r + vol * vol / 2.0) * time_to_maturity) / (
        vol * sqrt(time_to_maturity)
    )
    d2 = d1 - vol * sqrt(time_to_maturity)

    if optype == "call":
        premium = round(
            (
                s * stats.norm.cdf(d1)
                - x * exp(-r * time_to_maturity) * stats.norm.cdf(d2)
            ),
            2,
        )
    elif optype == "put":
        premium = round(
            (
                x * exp(-r * time_to_maturity) * stats.norm.cdf(-d2)
                - s * stats.norm.cdf(-d1)
            ),
            2,
        )

    return premium
